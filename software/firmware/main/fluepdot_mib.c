/*
Generated by LwipMibCompiler
*/

#include "lwip/apps/snmp_opts.h"
#if LWIP_SNMP

#include "main.h"
#include "flipdot.h"

#include "fluepdot_mib.h"
#include "lwip/apps/snmp.h"
#include "lwip/apps/snmp_core.h"
#include "lwip/apps/snmp_scalar.h"
#include "lwip/apps/snmp_table.h"

static struct {
    u32_t x;
    u32_t y;
} coordinate;

/* --- framebuffer 4294967295.54722.1.1.1 ----------------------------------------------------- */
static s16_t framebuffer_treenode_get_value(struct snmp_node_instance *instance, void *value);
static const struct snmp_scalar_node width_scalar = SNMP_SCALAR_CREATE_NODE_READONLY(1, SNMP_ASN1_TYPE_INTEGER, framebuffer_treenode_get_value);

static const struct snmp_scalar_node height_scalar = SNMP_SCALAR_CREATE_NODE_READONLY(2, SNMP_ASN1_TYPE_INTEGER, framebuffer_treenode_get_value);

static snmp_err_t pixelstable_get_instance(const u32_t *column, const u32_t *row_oid, u8_t row_oid_len, struct snmp_node_instance *cell_instance);
static snmp_err_t pixelstable_get_next_instance(const u32_t *column, struct snmp_obj_id *row_oid, struct snmp_node_instance *cell_instance);
static s16_t pixelstable_get_value(struct snmp_node_instance *cell_instance, void *value);
static snmp_err_t pixelstable_set_test(struct snmp_node_instance *cell_instance, u16_t len, void *value);
static snmp_err_t pixelstable_set_value(struct snmp_node_instance *cell_instance, u16_t len, void *value);
static const struct snmp_table_col_def pixelstable_columns[] = {
  {1, SNMP_ASN1_TYPE_INTEGER, SNMP_NODE_INSTANCE_READ_ONLY}, /* pixelX */ 
  {2, SNMP_ASN1_TYPE_INTEGER, SNMP_NODE_INSTANCE_READ_ONLY}, /* pixelY */ 
  {3, SNMP_ASN1_TYPE_INTEGER, SNMP_NODE_INSTANCE_READ_WRITE}, /* pixelState */ 
};
static const struct snmp_table_node pixelstable = SNMP_TABLE_CREATE(3, pixelstable_columns, pixelstable_get_instance, pixelstable_get_next_instance, pixelstable_get_value, pixelstable_set_test, pixelstable_set_value);

static const struct snmp_node *const framebuffer_subnodes[] = {
  &width_scalar.node.node,
  &height_scalar.node.node,
  &pixelstable.node.node
};
static const struct snmp_tree_node framebuffer_treenode = SNMP_CREATE_TREE_NODE(1, framebuffer_subnodes);

/* --- panels 4294967295.54722.1.1.2 ----------------------------------------------------- */
static s16_t panelCount_get_value(struct snmp_node_instance *instance, void *value);
static const struct snmp_scalar_node panelcount_scalar = SNMP_SCALAR_CREATE_NODE_READONLY(1, SNMP_ASN1_TYPE_INTEGER, panelCount_get_value);

static snmp_err_t paneltable_get_instance(const u32_t *column, const u32_t *row_oid, u8_t row_oid_len, struct snmp_node_instance *cell_instance);
static snmp_err_t paneltable_get_next_instance(const u32_t *column, struct snmp_obj_id *row_oid, struct snmp_node_instance *cell_instance);
static s16_t paneltable_get_value(struct snmp_node_instance *cell_instance, void *value);
static const struct snmp_table_col_def paneltable_columns[] = {
  {1, SNMP_ASN1_TYPE_INTEGER, SNMP_NODE_INSTANCE_READ_ONLY}, /* panelIndex */ 
  {2, SNMP_ASN1_TYPE_INTEGER, SNMP_NODE_INSTANCE_READ_ONLY}, /* panelWidth */ 
  {3, SNMP_ASN1_TYPE_INTEGER, SNMP_NODE_INSTANCE_READ_ONLY}, /* panelX */ 
};
static const struct snmp_table_node paneltable = SNMP_TABLE_CREATE(2, paneltable_columns, paneltable_get_instance, paneltable_get_next_instance, paneltable_get_value, NULL, NULL);

static const struct snmp_node *const panels_subnodes[] = {
  &panelcount_scalar.node.node,
  &paneltable.node.node
};
static const struct snmp_tree_node panels_treenode = SNMP_CREATE_TREE_NODE(2, panels_subnodes);

/* --- renderingOptions 4294967295.54722.1.1.3 ----------------------------------------------------- */
static snmp_err_t delaytable_get_instance(const u32_t *column, const u32_t *row_oid, u8_t row_oid_len, struct snmp_node_instance *cell_instance);
static snmp_err_t delaytable_get_next_instance(const u32_t *column, struct snmp_obj_id *row_oid, struct snmp_node_instance *cell_instance);
static s16_t delaytable_get_value(struct snmp_node_instance *cell_instance, void *value);
static snmp_err_t delaytable_set_test(struct snmp_node_instance *cell_instance, u16_t len, void *value);
static snmp_err_t delaytable_set_value(struct snmp_node_instance *cell_instance, u16_t len, void *value);
static const struct snmp_table_col_def delaytable_columns[] = {
  {1, SNMP_ASN1_TYPE_INTEGER, SNMP_NODE_INSTANCE_READ_ONLY}, /* column */ 
  {2, SNMP_ASN1_TYPE_INTEGER, SNMP_NODE_INSTANCE_READ_WRITE}, /* columnPreDelay */ 
  {3, SNMP_ASN1_TYPE_INTEGER, SNMP_NODE_INSTANCE_READ_WRITE}, /* columnSetDelay */ 
  {4, SNMP_ASN1_TYPE_INTEGER, SNMP_NODE_INSTANCE_READ_WRITE}, /* columnClearDelay */ 
};
static const struct snmp_table_node delaytable = SNMP_TABLE_CREATE(1, delaytable_columns, delaytable_get_instance, delaytable_get_next_instance, delaytable_get_value, delaytable_set_test, delaytable_set_value);

static snmp_err_t panelordertable_get_instance(const u32_t *column, const u32_t *row_oid, u8_t row_oid_len, struct snmp_node_instance *cell_instance);
static snmp_err_t panelordertable_get_next_instance(const u32_t *column, struct snmp_obj_id *row_oid, struct snmp_node_instance *cell_instance);
static s16_t panelordertable_get_value(struct snmp_node_instance *cell_instance, void *value);
static snmp_err_t panelordertable_set_test(struct snmp_node_instance *cell_instance, u16_t len, void *value);
static snmp_err_t panelordertable_set_value(struct snmp_node_instance *cell_instance, u16_t len, void *value);
static const struct snmp_table_col_def panelordertable_columns[] = {
  {1, SNMP_ASN1_TYPE_INTEGER, SNMP_NODE_INSTANCE_READ_ONLY}, /* orderIndex */ 
  {2, SNMP_ASN1_TYPE_INTEGER, SNMP_NODE_INSTANCE_READ_WRITE}, /* panelOrderIndex */ 
};
static const struct snmp_table_node panelordertable = SNMP_TABLE_CREATE(2, panelordertable_columns, panelordertable_get_instance, panelordertable_get_next_instance, panelordertable_get_value, panelordertable_set_test, panelordertable_set_value);

static s16_t renderingMode_get_value(struct snmp_node_instance *instance, void *value);
static snmp_err_t renderingMode_set_test(struct snmp_node_instance *instance, u16_t len, void *value);
static snmp_err_t renderingMode_set_value(struct snmp_node_instance *instance, u16_t len, void *value);
static const struct snmp_scalar_node renderingmode_scalar = SNMP_SCALAR_CREATE_NODE(3, SNMP_NODE_INSTANCE_READ_WRITE, SNMP_ASN1_TYPE_INTEGER, renderingMode_get_value, renderingMode_set_test, renderingMode_set_value);

static const struct snmp_node *const renderingoptions_subnodes[] = {
  &delaytable.node.node,
  &panelordertable.node.node,
  &renderingmode_scalar.node.node
};
static const struct snmp_tree_node renderingoptions_treenode = SNMP_CREATE_TREE_NODE(3, renderingoptions_subnodes);

/* --- fluepdot 4294967295.54722.1.1 ----------------------------------------------------- */
static s16_t fluepdot_treenode_get_value(struct snmp_node_instance *instance, void *value);
static snmp_err_t fluepdot_treenode_set_test(struct snmp_node_instance *instance, u16_t len, void *value);
static snmp_err_t fluepdot_treenode_set_value(struct snmp_node_instance *instance, u16_t len, void *value);
static const struct snmp_scalar_node pixelsflipped_scalar = SNMP_SCALAR_CREATE_NODE_READONLY(4, SNMP_ASN1_TYPE_COUNTER64, fluepdot_treenode_get_value);

static const struct snmp_scalar_node dirtybit_scalar = SNMP_SCALAR_CREATE_NODE(69, SNMP_NODE_INSTANCE_READ_WRITE, SNMP_ASN1_TYPE_INTEGER, fluepdot_treenode_get_value, fluepdot_treenode_set_test, fluepdot_treenode_set_value);

static const struct snmp_node *const fluepdot_subnodes[] = {
  &framebuffer_treenode.node,
  &panels_treenode.node,
  &renderingoptions_treenode.node,
  &pixelsflipped_scalar.node.node,
  &dirtybit_scalar.node.node
};
static const struct snmp_tree_node fluepdot_treenode = SNMP_CREATE_TREE_NODE(1, fluepdot_subnodes);

/* --- projects 4294967295.54722.1 ----------------------------------------------------- */
static const struct snmp_node *const projects_subnodes[] = {
  &fluepdot_treenode.node
};
static const struct snmp_tree_node projects_treenode = SNMP_CREATE_TREE_NODE(1, projects_subnodes);

/* --- fluepke  ----------------------------------------------------- */
static const struct snmp_node *const fluepke_subnodes[] = {
  &projects_treenode.node
};
static const struct snmp_tree_node fluepke_root = SNMP_CREATE_TREE_NODE(54722, fluepke_subnodes);
static const u32_t fluepke_base_oid[] = {1, 3, 6, 1, 4, 1, 54722};
const struct snmp_mib fluepke = {fluepke_base_oid, LWIP_ARRAYSIZE(fluepke_base_oid), &fluepke_root.node};



/*
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
LWIP MIB generator - preserved section begin
Code below is preserved on regeneration. Remove these comment lines to regenerate code.
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
*/

/* --- framebuffer 4294967295.54722.1.1.1 ----------------------------------------------------- */
static snmp_err_t pixelstable_get_instance(const u32_t *column, const u32_t *row_oid, u8_t row_oid_len, struct snmp_node_instance *cell_instance)
{
   /*
   The instance OID of this table consists of following (index) column(s):
    pixelX (Integer, OID length = 1)
    pixelY (Integer, OID length = 1)
   */
   snmp_err_t err = SNMP_ERR_NOSUCHINSTANCE;

   if (row_oid_len == 2)
   {
      LWIP_UNUSED_ARG(column);
      LWIP_UNUSED_ARG(row_oid);
      LWIP_UNUSED_ARG(cell_instance);

      uint32_t x = row_oid[0];
      uint32_t y = row_oid[1];

      if ((x < 115) && (y < 16)) {
          coordinate.x = x;
          coordinate.y = y;
          cell_instance->reference.ptr = (void*)&coordinate;
          return SNMP_ERR_NOERROR;
      }
   }
   return err;
}
static snmp_err_t pixelstable_get_next_instance(const u32_t *column, struct snmp_obj_id *row_oid, struct snmp_node_instance *cell_instance)
{
   /*
   The instance OID of this table consists of following (index) column(s):
    pixelX (Integer, OID length = 1)
    pixelY (Integer, OID length = 1)
   */
   snmp_err_t err = SNMP_ERR_NOSUCHINSTANCE;

   LWIP_UNUSED_ARG(column);
   LWIP_UNUSED_ARG(row_oid);
   LWIP_UNUSED_ARG(cell_instance);
   
   if (row_oid->len == 0) {
       coordinate.x = 0;
       coordinate.y = 0;
       cell_instance->reference.ptr = (void*)&coordinate;
       row_oid->id[0] = 0;
       row_oid->id[1] = 0;
       row_oid->len = 2;
       err = SNMP_ERR_NOERROR;
   } else if (row_oid->len == 2) {
       uint32_t x = row_oid->id[0];
       uint32_t y = row_oid->id[1];

       if (y >= 15) {
           y = 0;
           x++;
       } else {
           y++;
       }

       if (x < flipdot.width) {
          row_oid->id[0] = x;
          row_oid->id[1] = y;
          coordinate.x = x;
          coordinate.y = y;
          cell_instance->reference.ptr = (void*)&coordinate;
          err = SNMP_ERR_NOERROR;
       }
   }
   return err;
}

static s16_t pixelstable_get_value(struct snmp_node_instance *cell_instance, void *value)
{
   s16_t value_len;

   switch (SNMP_TABLE_GET_COLUMN_FROM_OID(cell_instance->instance_oid.id))
   {
      case 1:
         {
            /* pixelX */
            s32_t *v = (s32_t *)value;

            *v = coordinate.x;
            value_len = sizeof(s32_t);
            LWIP_UNUSED_ARG(v);
         }
         break;
      case 2:
         {
            /* pixelY */
            s32_t *v = (s32_t *)value;

            *v = coordinate.y;
            value_len = sizeof(s32_t);
            LWIP_UNUSED_ARG(v);
         }
         break;
      case 3:
         {
            /* pixelState */
            s32_t *v = (s32_t *)value;

            *v = flipdot_framebuffer_get_pixel(flipdot.framebuffer, (uint8_t)coordinate.x, (uint8_t)coordinate.y);
            value_len = sizeof(s32_t);
            LWIP_UNUSED_ARG(v);
         }
         break;
      default:
         {
            LWIP_DEBUGF(SNMP_MIB_DEBUG,("pixelstable_get_value(): unknown id: %"S32_F"\n", SNMP_TABLE_GET_COLUMN_FROM_OID(cell_instance->instance_oid.id)));
            value_len = 0;
         }
         break;
   }
   return value_len;
}

static snmp_err_t pixelstable_set_test(struct snmp_node_instance *cell_instance, u16_t len, void *value)
{
   snmp_err_t err = SNMP_ERR_WRONGVALUE;

   switch (SNMP_TABLE_GET_COLUMN_FROM_OID(cell_instance->instance_oid.id))
   {
      case 3:
         {
            /* pixelState */
            s32_t *v = (s32_t *)value;
            
            LWIP_ASSERT("Invalid length for datatype", (len == sizeof(s32_t)));
            if (((*v >= 0) && (*v <= 1)))
            {
               err = SNMP_ERR_NOERROR;
            }
         }
         break;
      default:
         {
            LWIP_DEBUGF(SNMP_MIB_DEBUG,("pixelstable_set_test(): unknown id: %"S32_F"\n", SNMP_TABLE_GET_COLUMN_FROM_OID(cell_instance->instance_oid.id)));
         }
         break;
   }
   return err;
}

static snmp_err_t pixelstable_set_value(struct snmp_node_instance *cell_instance, u16_t len, void *value)
{
   snmp_err_t err = SNMP_ERR_NOERROR;

   LWIP_UNUSED_ARG(len);
   switch (SNMP_TABLE_GET_COLUMN_FROM_OID(cell_instance->instance_oid.id))
   {
      case 3:
         {
            /* pixelState */
            s32_t *v = (s32_t *)value;

            flipdot_framebuffer_set_pixel(flipdot.framebuffer, (uint8_t)coordinate.x, (uint8_t)coordinate.y, *v > 0);
         }
         break;
      default:
         {
            LWIP_DEBUGF(SNMP_MIB_DEBUG,("pixelstable_set_value(): unknown id: %"S32_F"\n", SNMP_TABLE_GET_COLUMN_FROM_OID(cell_instance->instance_oid.id)));
         }
         break;
   }
   return err;
}

static s16_t framebuffer_treenode_get_value(struct snmp_node_instance *instance, void *value)
{
   s16_t value_len;

   switch (instance->node->oid)
   {
      case 1:
         {
            /* width */
            s32_t *v = (s32_t *)value;

            *v = flipdot.width;
            value_len = sizeof(s32_t);
         }
         break;
      case 2:
         {
            /* height */
            s32_t *v = (s32_t *)value;

            *v = 16;
            value_len = sizeof(s32_t);
         }
         break;
      default:
         {
            LWIP_DEBUGF(SNMP_MIB_DEBUG,("framebuffer_treenode_get_value(): unknown id: %"S32_F"\n", instance->node->oid));
            value_len = 0;
         }
         break;
   }
   return value_len;
}

/* --- panels 4294967295.54722.1.1.2 ----------------------------------------------------- */
static s16_t panelCount_get_value(struct snmp_node_instance *instance, void *value)
{
   s16_t value_len;
   s32_t *v = (s32_t *)value;

   LWIP_UNUSED_ARG(instance);
   *v = flipdot.panel_count;
   value_len = sizeof(s32_t);
   return value_len;
}

static snmp_err_t paneltable_get_instance(const u32_t *column, const u32_t *row_oid, u8_t row_oid_len, struct snmp_node_instance *cell_instance)
{
   /*
   The instance OID of this table consists of following (index) column(s):
    panelIndex (Integer, OID length = 1)
   */
   snmp_err_t err = SNMP_ERR_NOSUCHINSTANCE;

   if (row_oid_len == 1)
   {
      LWIP_UNUSED_ARG(column);
      LWIP_UNUSED_ARG(row_oid);
      LWIP_UNUSED_ARG(cell_instance);

      uint32_t panel_id = row_oid[0];

      if (panel_id < flipdot.panel_count) {
          coordinate.x = panel_id;
          cell_instance->reference.ptr = (void*)&coordinate;
          return SNMP_ERR_NOERROR;
      }
   }
   return err;
}

static snmp_err_t paneltable_get_next_instance(const u32_t *column, struct snmp_obj_id *row_oid, struct snmp_node_instance *cell_instance)
{
   /*
   The instance OID of this table consists of following (index) column(s):
    panelIndex (Integer, OID length = 1)
   */
   snmp_err_t err = SNMP_ERR_NOSUCHINSTANCE;

   LWIP_UNUSED_ARG(column);
   LWIP_UNUSED_ARG(row_oid);
   LWIP_UNUSED_ARG(cell_instance);

   if (row_oid->len == 0) {
       row_oid->id[0] = 0;
       row_oid->len = 1;
       coordinate.x = 0;
       cell_instance->reference.ptr = (void*)&coordinate;
       err = SNMP_ERR_NOERROR;
   } else if (row_oid->len == 1) {
       uint32_t panel_index = row_oid->id[0];
       panel_index++;

       if (panel_index < flipdot.panel_count) {
           row_oid->id[0] = panel_index;
           coordinate.x = panel_index;
           cell_instance->reference.ptr = (void*)&coordinate;
           err = SNMP_ERR_NOERROR;
       }
   }
   return err;
}
static s16_t paneltable_get_value(struct snmp_node_instance *cell_instance, void *value)
{
   s16_t value_len;

   switch (SNMP_TABLE_GET_COLUMN_FROM_OID(cell_instance->instance_oid.id))
   {
      case 1:
         {
            /* panelIndex */
            s32_t *v = (s32_t *)value;
            *v = coordinate.x;
            value_len = sizeof(s32_t);
         }
         break;
      case 2:
         {
            /* panelWidth */
            s32_t *v = (s32_t *)value;
            if (coordinate.x < flipdot.panel_count) {
                *v = flipdot.panels[coordinate.x].width;
            }
            value_len = sizeof(s32_t);
         }
         break;
      case 3:
         {
            /* panelX */
            s32_t *v = (s32_t *)value;
            if (coordinate.x < flipdot.panel_count) {
                *v = flipdot.panels[coordinate.x].x;
            }
            value_len = sizeof(s32_t);
         }
         break;
      default:
         {
            LWIP_DEBUGF(SNMP_MIB_DEBUG,("paneltable_get_value(): unknown id: %"S32_F"\n", SNMP_TABLE_GET_COLUMN_FROM_OID(cell_instance->instance_oid.id)));
            value_len = 0;
         }
         break;
   }
   return value_len;
}

/* --- renderingOptions 4294967295.54722.1.1.3 ----------------------------------------------------- */
static snmp_err_t delaytable_get_instance(const u32_t *column, const u32_t *row_oid, u8_t row_oid_len, struct snmp_node_instance *cell_instance)
{
   /*
   The instance OID of this table consists of following (index) column(s):
    column (Integer, OID length = 1)
   */
   snmp_err_t err = SNMP_ERR_NOSUCHINSTANCE;

   if (row_oid_len == 1)
   {
      LWIP_UNUSED_ARG(column);
      LWIP_UNUSED_ARG(row_oid);
      LWIP_UNUSED_ARG(cell_instance);

      u32_t x = row_oid[0];
      if (x < flipdot.width) {
          coordinate.x = x;
          cell_instance->reference.ptr = (void*)&coordinate;
          err = SNMP_ERR_NOERROR;
      }
   }
   return err;
}

static snmp_err_t delaytable_get_next_instance(const u32_t *column, struct snmp_obj_id *row_oid, struct snmp_node_instance *cell_instance)
{
   /*
   The instance OID of this table consists of following (index) column(s):
    column (Integer, OID length = 1)
   */
   snmp_err_t err = SNMP_ERR_NOSUCHINSTANCE;

   LWIP_UNUSED_ARG(column);
   LWIP_UNUSED_ARG(row_oid);
   LWIP_UNUSED_ARG(cell_instance);

   if (row_oid->len == 0) {
       row_oid->id[0] = 0;
       row_oid->len = 1;
       coordinate.x = 0;
       cell_instance->reference.ptr = (void*)&coordinate;
       err = SNMP_ERR_NOERROR;
   } else if (row_oid->len == 1) {
       u32_t x = row_oid->id[0];

       x++;

       if (x < flipdot.width) {
           row_oid->id[0] = x;
           coordinate.x = x;
           cell_instance->reference.ptr = (void*)&coordinate;
           err = SNMP_ERR_NOERROR;
       }
   }
   return err;
}

static s16_t delaytable_get_value(struct snmp_node_instance *cell_instance, void *value)
{
   s16_t value_len;

   switch (SNMP_TABLE_GET_COLUMN_FROM_OID(cell_instance->instance_oid.id))
   {
      case 1:
         {
            /* column */
            s32_t *v = (s32_t *)value;
            *v = coordinate.x;
            value_len = sizeof(s32_t);
         }
         break;
      case 2:
         {
            /* columnPreDelay */
            s32_t *v = (s32_t *)value;
            if (coordinate.x < flipdot.width) {
                *v = flipdot.rendering_options->delay_options[coordinate.x].pre_delay;
            }
            value_len = sizeof(s32_t);
         }
         break;
      case 3:
         {
            /* columnSetDelay */
            s32_t *v = (s32_t *)value;
            if (coordinate.x < flipdot.width) {
                *v = flipdot.rendering_options->delay_options[coordinate.x].set_delay;
            }
            value_len = sizeof(s32_t);
         }
         break;
      case 4:
         {
            /* columnClearDelay */
            s32_t *v = (s32_t *)value;
            if (coordinate.x < flipdot.width) {
                *v = flipdot.rendering_options->delay_options[coordinate.x].clear_delay;
            }
            value_len = sizeof(s32_t);
         }
         break;
      default:
         {
            LWIP_DEBUGF(SNMP_MIB_DEBUG,("delaytable_get_value(): unknown id: %"S32_F"\n", SNMP_TABLE_GET_COLUMN_FROM_OID(cell_instance->instance_oid.id)));
            value_len = 0;
         }
         break;
   }
   return value_len;
}
static snmp_err_t delaytable_set_test(struct snmp_node_instance *cell_instance, u16_t len, void *value)
{
   snmp_err_t err = SNMP_ERR_WRONGVALUE;

   LWIP_UNUSED_ARG(value);
   LWIP_UNUSED_ARG(len);
   switch (SNMP_TABLE_GET_COLUMN_FROM_OID(cell_instance->instance_oid.id))
   {
      case 2:
         {
            /* columnPreDelay */

            err = SNMP_ERR_NOERROR;
         }
         break;
      case 3:
         {
            /* columnSetDelay */

            err = SNMP_ERR_NOERROR;
         }
         break;
      case 4:
         {
            /* columnClearDelay */

            err = SNMP_ERR_NOERROR;
         }
         break;
      default:
         {
            LWIP_DEBUGF(SNMP_MIB_DEBUG,("delaytable_set_test(): unknown id: %"S32_F"\n", SNMP_TABLE_GET_COLUMN_FROM_OID(cell_instance->instance_oid.id)));
         }
         break;
   }
   return err;
}
static snmp_err_t delaytable_set_value(struct snmp_node_instance *cell_instance, u16_t len, void *value)
{
   snmp_err_t err = SNMP_ERR_NOERROR;

   LWIP_UNUSED_ARG(len);
   switch (SNMP_TABLE_GET_COLUMN_FROM_OID(cell_instance->instance_oid.id))
   {
      case 2:
         {
            /* columnPreDelay */
            s32_t *v = (s32_t *)value;
            if (coordinate.x < flipdot.width) {
                flipdot.rendering_options->delay_options[coordinate.x].pre_delay = (uint16_t)*v;
            }
         }
         break;
      case 3:
         {
            /* columnSetDelay */
            s32_t *v = (s32_t *)value;
            if (coordinate.x < flipdot.width) {
                flipdot.rendering_options->delay_options[coordinate.x].set_delay = (uint16_t)*v;
            }
         }
         break;
      case 4:
         {
            /* columnClearDelay */
            s32_t *v = (s32_t *)value;
            if (coordinate.x < flipdot.width) {
                flipdot.rendering_options->delay_options[coordinate.x].clear_delay = (uint16_t)*v;
            }
         }
         break;
      default:
         {
            LWIP_DEBUGF(SNMP_MIB_DEBUG,("delaytable_set_value(): unknown id: %"S32_F"\n", SNMP_TABLE_GET_COLUMN_FROM_OID(cell_instance->instance_oid.id)));
         }
         break;
   }
   return err;
}

static snmp_err_t panelordertable_get_instance(const u32_t *column, const u32_t *row_oid, u8_t row_oid_len, struct snmp_node_instance *cell_instance)
{
   /*
   The instance OID of this table consists of following (index) column(s):
    orderIndex (Integer, OID length = 1)
   */
   snmp_err_t err = SNMP_ERR_NOSUCHINSTANCE;

   if (row_oid_len == 1)
   {
      LWIP_UNUSED_ARG(column);
      LWIP_UNUSED_ARG(row_oid);
      LWIP_UNUSED_ARG(cell_instance);

      u32_t panel_index = row_oid[0];

      if (panel_index < flipdot.rendering_options->panel_count) {
          coordinate.x = panel_index;
          cell_instance->reference.ptr = (void*)&coordinate;
          err = SNMP_ERR_NOERROR;
      }
   }
   return err;
}

static snmp_err_t panelordertable_get_next_instance(const u32_t *column, struct snmp_obj_id *row_oid, struct snmp_node_instance *cell_instance)
{
   /*
   The instance OID of this table consists of following (index) column(s):
    orderIndex (Integer, OID length = 1)
   */
   snmp_err_t err = SNMP_ERR_NOSUCHINSTANCE;

   LWIP_UNUSED_ARG(column);
   LWIP_UNUSED_ARG(row_oid);
   LWIP_UNUSED_ARG(cell_instance);

   if (row_oid->len == 0) {
       row_oid->id[0] = 0;
       row_oid->len = 1;
       coordinate.x = 0;
       cell_instance->reference.ptr = (void*)&coordinate;
       err = SNMP_ERR_NOERROR;
   } else if (row_oid->len == 1) {
       u32_t panel_index = row_oid->id[0];

       panel_index++;
       if (panel_index < flipdot.rendering_options->panel_count) {
           row_oid->id[0] = panel_index;
           coordinate.x = panel_index;
           cell_instance->reference.ptr = (void*)&coordinate;
           err = SNMP_ERR_NOERROR;
       }
   }
   return err;
}

static s16_t panelordertable_get_value(struct snmp_node_instance *cell_instance, void *value)
{
   s16_t value_len;

   switch (SNMP_TABLE_GET_COLUMN_FROM_OID(cell_instance->instance_oid.id))
   {
      case 1:
         {
            /* orderIndex */
            s32_t *v = (s32_t *)value;
            *v = coordinate.x;
            value_len = sizeof(s32_t);
         }
         break;
      case 2:
         {
            /* panelOrderIndex */
            s32_t *v = (s32_t *)value;
            if (coordinate.x < flipdot.rendering_options->panel_count) {
                *v = flipdot.rendering_options->panel_order[coordinate.x];
            }
            value_len = sizeof(s32_t);
         }
         break;
      default:
         {
            LWIP_DEBUGF(SNMP_MIB_DEBUG,("panelordertable_get_value(): unknown id: %"S32_F"\n", SNMP_TABLE_GET_COLUMN_FROM_OID(cell_instance->instance_oid.id)));
            value_len = 0;
         }
         break;
   }
   return value_len;
}
static snmp_err_t panelordertable_set_test(struct snmp_node_instance *cell_instance, u16_t len, void *value)
{
   snmp_err_t err = SNMP_ERR_WRONGVALUE;

   switch (SNMP_TABLE_GET_COLUMN_FROM_OID(cell_instance->instance_oid.id))
   {
      case 2:
         {
            /* panelOrderIndex */
            s32_t *v = (s32_t *)value;

            LWIP_ASSERT("Invalid length for datatype", (len == sizeof(s32_t)));
            if (((*v >= 0) && (*v < flipdot.rendering_options->panel_count)))
            {
               err = SNMP_ERR_NOERROR;
            }
         }
         break;
      default:
         {
            LWIP_DEBUGF(SNMP_MIB_DEBUG,("panelordertable_set_test(): unknown id: %"S32_F"\n", SNMP_TABLE_GET_COLUMN_FROM_OID(cell_instance->instance_oid.id)));
         }
         break;
   }
   return err;
}
static snmp_err_t panelordertable_set_value(struct snmp_node_instance *cell_instance, u16_t len, void *value)
{
   snmp_err_t err = SNMP_ERR_NOERROR;

   LWIP_UNUSED_ARG(len);
   switch (SNMP_TABLE_GET_COLUMN_FROM_OID(cell_instance->instance_oid.id))
   {
      case 2:
         {
            /* panelOrderIndex */
            s32_t *v = (s32_t *)value;
            if (coordinate.x < flipdot.rendering_options->panel_count) {
                flipdot.rendering_options->panel_order[coordinate.x] = (uint8_t)*v;
            }
         }
         break;
      default:
         {
            LWIP_DEBUGF(SNMP_MIB_DEBUG,("panelordertable_set_value(): unknown id: %"S32_F"\n", SNMP_TABLE_GET_COLUMN_FROM_OID(cell_instance->instance_oid.id)));
         }
         break;
   }
   return err;
}

static s16_t renderingMode_get_value(struct snmp_node_instance *instance, void *value)
{
   s16_t value_len;
   s32_t *v = (s32_t *)value;
   *v = flipdot.rendering_options->mode;
   value_len = sizeof(s32_t);
   return value_len;
}
static snmp_err_t renderingMode_set_test(struct snmp_node_instance *instance, u16_t len, void *value)
{
   snmp_err_t err = SNMP_ERR_WRONGVALUE;
   s32_t *v = (s32_t *)value;

   LWIP_UNUSED_ARG(instance);
   LWIP_ASSERT("Invalid length for datatype", (len == sizeof(s32_t)));
   if (((*v >= 0) && (*v <= 1)))
   {
      err = SNMP_ERR_NOERROR;
   }
   return err;
}
static snmp_err_t renderingMode_set_value(struct snmp_node_instance *instance, u16_t len, void *value)
{
   snmp_err_t err = SNMP_ERR_NOERROR;
   s32_t *v = (s32_t *)value;

   LWIP_UNUSED_ARG(instance);
   flipdot.rendering_options->mode = (flipdot_rendering_mode_t)*v;
   LWIP_UNUSED_ARG(len);
   return err;
}

/* --- fluepdot 4294967295.54722.1.1 ----------------------------------------------------- */
static s16_t fluepdot_treenode_get_value(struct snmp_node_instance *instance, void *value)
{
   s16_t value_len;

   switch (instance->node->oid)
   {
      case 4:
         {
            /* pixelsFlipped */
            u32_t *v_high = (u32_t *)value;
            u32_t *v_low = v_high + 1;

            *v_low = (u32_t)(flipdot.pixels_flipped >> 32);
            *v_high = (u32_t)flipdot.pixels_flipped;
            value_len = (2 * sizeof(u32_t));
         }
         break;
      case 69:
         {
            /* dirtyBit */
            s32_t *v = (s32_t *)value;
            *v = 0;
            value_len = sizeof(s32_t);
         }
         break;
      default:
         {
            LWIP_DEBUGF(SNMP_MIB_DEBUG,("fluepdot_treenode_get_value(): unknown id: %"S32_F"\n", instance->node->oid));
            value_len = 0;
         }
         break;
   }
   return value_len;
}
static snmp_err_t fluepdot_treenode_set_test(struct snmp_node_instance *instance, u16_t len, void *value)
{
   snmp_err_t err = SNMP_ERR_WRONGVALUE;

   LWIP_UNUSED_ARG(value);
   LWIP_UNUSED_ARG(len);
   switch (instance->node->oid)
   {
      case 69:
         {
            /* dirtyBit */

            err = SNMP_ERR_NOERROR;
         }
         break;
      default:
         {
            LWIP_DEBUGF(SNMP_MIB_DEBUG,("fluepdot_treenode_set_test(): unknown id: %"S32_F"\n", instance->node->oid));
         }
         break;
   }
   return err;
}
static snmp_err_t fluepdot_treenode_set_value(struct snmp_node_instance *instance, u16_t len, void *value)
{
   snmp_err_t err = SNMP_ERR_NOERROR;

   LWIP_UNUSED_ARG(len);
   switch (instance->node->oid)
   {
      case 69:
         {
            /* dirtyBit */
            s32_t *v = (s32_t *)value;
            if (*v > 0) {
                flipdot_set_dirty_flag(&flipdot);
            }
         }
         break;
      default:
         {
            LWIP_DEBUGF(SNMP_MIB_DEBUG,("fluepdot_treenode_set_value(): unknown id: %"S32_F"\n", instance->node->oid));
         }
         break;
   }
   return err;
}

/* --- projects 4294967295.54722.1 ----------------------------------------------------- */
/* --- fluepke  ----------------------------------------------------- */
#endif /* LWIP_SNMP */

